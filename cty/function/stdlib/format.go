package stdlib

import (
	"bytes"
	"fmt"

	"github.com/zclconf/go-cty/cty"
	"github.com/zclconf/go-cty/cty/function"
)

//go:generate ragel -Z format_fsm.rl
//go:generate gofmt -w format_fsm.go

var FormatFunc = function.New(&function.Spec{
	Params: []function.Parameter{
		{
			Name: "format",
			Type: cty.String,
		},
	},
	VarParam: &function.Parameter{
		Name:      "args",
		Type:      cty.DynamicPseudoType,
		AllowNull: true,
	},
	Type: function.StaticReturnType(cty.String),
	Impl: func(args []cty.Value, retType cty.Type) (cty.Value, error) {
		str, err := formatFSM(args[0].AsString(), args[1:])
		return cty.StringVal(str), err
	},
})

var FormatListFunc = function.New(&function.Spec{
	Params: []function.Parameter{
		{
			Name: "format",
			Type: cty.String,
		},
	},
	VarParam: &function.Parameter{
		Name:      "args",
		Type:      cty.DynamicPseudoType,
		AllowNull: true,
	},
	Type: function.StaticReturnType(cty.List(cty.String)),
	Impl: func(args []cty.Value, retType cty.Type) (cty.Value, error) {
		panic("formatlist is not yet implemented")
	},
})

type formatVerb struct {
	Raw    string
	Offset int

	ArgNum int
	Mode   rune

	Zero  bool
	Sharp bool
	Plus  bool
	Minus bool
	Space bool

	HasPrec     bool
	Prec        int
	PrecFromArg bool

	HasWidth     bool
	Width        int
	WidthFromArg bool
}

func (v *formatVerb) argsConsumed() int {
	ret := 1
	if v.WidthFromArg {
		ret++
	}
	if v.PrecFromArg {
		ret++
	}
	return ret
}

func (v *formatVerb) nextArg() int {
	return v.ArgNum + v.argsConsumed()
}

func (v *formatVerb) startArgIdx() int {
	// ArgNum is 1-indexed, but our args array is zero-indexed
	return v.ArgNum - 1
}

func (v *formatVerb) endArgIdx() int {
	// This is _exclusive_, like a slice end argument
	return v.startArgIdx() + v.argsConsumed()
}

func (v *formatVerb) hasEnoughArgs(args []cty.Value) bool {
	return v.endArgIdx() <= len(args)
}

func (v *formatVerb) selectArgs(args []cty.Value) []cty.Value {
	return args[v.startArgIdx():v.endArgIdx()]
}

// formatAppend is called by formatFSM (generated by format_fsm.rl) for each
// formatting sequence that is encountered.
func formatAppend(verb *formatVerb, buf *bytes.Buffer, args []cty.Value) (int, error) {
	if !verb.hasEnoughArgs(args) {
		return verb.nextArg(), fmt.Errorf(
			"not enough arguments for %q at %d: requires at least %d total (%d starting at %d)",
			verb.Raw, verb.Offset,
			verb.endArgIdx(),
			verb.argsConsumed(), verb.ArgNum,
		)
	}

	// For our first pass we'll ensure the verb is supported and then fan
	// out to other functions based on what conversion is needed.
	switch verb.Mode {

	case 'v':
		return formatAppendAsIs(verb, buf, args)

	case 't':
		return formatAppendBool(verb, buf, args)

	case 'b', 'd', 'i', 'o', 'x', 'X', 'e', 'E', 'f', 'g', 'G':
		return formatAppendNumber(verb, buf, args)

	case 's', 'q':
		return formatAppendString(verb, buf, args)

	default:
		return verb.nextArg(), fmt.Errorf("unsupported format verb %q in %q at offset %d", verb.Mode, verb.Raw, verb.Offset)
	}
}

func formatAppendAsIs(verb *formatVerb, buf *bytes.Buffer, args []cty.Value) (int, error) {
	return verb.nextArg(), nil
}

func formatAppendBool(verb *formatVerb, buf *bytes.Buffer, args []cty.Value) (int, error) {
	return verb.nextArg(), nil
}

func formatAppendNumber(verb *formatVerb, buf *bytes.Buffer, args []cty.Value) (int, error) {
	return verb.nextArg(), nil
}

func formatAppendString(verb *formatVerb, buf *bytes.Buffer, args []cty.Value) (int, error) {
	return verb.nextArg(), nil
}

// Format produces a string representation of zero or more values using a
// format string similar to the "printf" function in C.
//
// It supports the following "verbs":
//
//     %%      Literal percent sign, consuming no value
//     %v      A default formatting of the value based on type, as described below.
//     %#v     JSON serialization of the value
//     %t      Converts to boolean and then produces "true" or "false"
//     %b      Converts to number, requires integer, produces binary representation
//     %d, %i  Converts to number, requires integer, produces decimal representation
//     %o      Converts to number, requires integer, produces octal representation
//     %x      Converts to number, requires integer, produces hexadecimal representation
//             with lowercase letters
//     %X      Like %x but with uppercase letters
//     %e      Converts to number, produces scientific notation like -1.234456e+78
//     %E      Like %e but with an uppercase "E" representing the exponent
//     %f      Converts to number, produces decimal representation with fractional
//             part but no exponent, like 123.456
//     %g      %e for large exponents or %f otherwise
//     %G      %E for large exponents or %f otherwise
//     %s      Converts to string and produces the string's characters
//     %q      Converts to string and produces JSON-quoted string representation,
//             like %v.
//
// The default format selections made by %v are:
//
//     string  %s
//     number  %g
//     bool    %t
//     other   %#v
//
// Null values produce the literal keyword "null" for %v and %#v, and produce
// an error otherwise.
//
// Width is specified by an optional decimal number immediately preceding the
// verb letter. If absent, the width is whatever is necessary to represent the
// value. Precision is specified after the (optional) width by a period
// followed by a decimal number. If no period is present, a default precision
// is used. A period with no following number is invalid.
// For examples:
//
//     %f     default width, default precision
//     %9f    width 9, default precision
//     %.2f   default width, precision 2
//     %9.2f  width 9, precision 2
//
// Width and precision are measured in unicode characters (grapheme clusters).
//
// For most values, width is the minimum number of characters to output,
// padding the formatted form with spaces if necessary.
//
// For strings, precision limits the length of the input to be formatted (not
// the size of the output), truncating if necessary.
//
// For numbers, width sets the minimum width of the field and precision sets
// the number of places after the decimal, if appropriate, except that for
// %g/%G precision sets the total number of significant digits.
//
// The following additional symbols can be used immediately after the percent
// introducer as flags:
//
//     +     Include a sign for a number even if it is positive (numeric only)
//     -     Pad with spaces on the left rather than the right
//     #     For %x, include 0x prefix
//           For %o, include 0 prefix
//           For %b, include 0b prefix
//           For decimal numeric formats, always include at least one decimal place.
//     0     Pad with zeros rather than spaces.
//
// Flag characters are ignored for verbs that do not support them.
//
// By default, % sequences consume successive arguments starting with the first.
// Introducing a [n] sequence immediately before the verb letter, where n is a
// decimal integer, explicitly chooses a particular value argument by its
// one-based index. Subsequent calls without an explicit index will then
// proceed with n+1, n+2, etc.
//
// An error is produced if the format string calls for an impossible conversion
// or accesses more values than are given. An error is produced also for
// an unsupported format verb.
func Format(format cty.Value, vals ...cty.Value) (cty.Value, error) {
	args := make([]cty.Value, 0, len(vals)+1)
	args = append(args, format)
	args = append(args, vals...)
	return FormatFunc.Call(args)
}

// FormatList applies the same formatting behavior as Format, but accepts
// a mixture of list and non-list values as arguments. Any list arguments
// passed must have the same length, which dictates the length of the
// resulting list.
//
// Any non-list arguments are used repeatedly for each iteration over the
// list arguments. The list arguments are iterated in order by key, so
// corresponding items are formatted together.
func FormatList(format cty.Value, vals ...cty.Value) (cty.Value, error) {
	args := make([]cty.Value, 0, len(vals)+1)
	args = append(args, format)
	args = append(args, vals...)
	return FormatListFunc.Call(args)
}
